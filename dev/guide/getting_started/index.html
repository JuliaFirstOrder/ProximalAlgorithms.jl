<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · ProximalAlgorithms.jl</title><meta name="title" content="Getting started · ProximalAlgorithms.jl"/><meta property="og:title" content="Getting started · ProximalAlgorithms.jl"/><meta property="twitter:title" content="Getting started · ProximalAlgorithms.jl"/><meta name="description" content="Documentation for ProximalAlgorithms.jl."/><meta property="og:description" content="Documentation for ProximalAlgorithms.jl."/><meta property="twitter:description" content="Documentation for ProximalAlgorithms.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ProximalAlgorithms.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User guide</span><ul><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#algorithm_interface"><span>Interface to algorithms</span></a></li><li><a class="tocitem" href="#box_qp"><span>Example: box constrained quadratic</span></a></li><li><a class="tocitem" href="#iterator_interface"><span>Iterator interface</span></a></li><li><a class="tocitem" href="#box_qp_cont"><span>Example: box constrained quadratic (cont)</span></a></li></ul></li><li><a class="tocitem" href="../implemented_algorithms/">Problem types and algorithms</a></li><li><a class="tocitem" href="../custom_objectives/">Custom objective terms</a></li><li><a class="tocitem" href="../custom_algorithms/">Custom algorithms</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/sparse_linear_regression/">Sparse linear regression</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User guide</a></li><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaFirstOrder/ProximalAlgorithms.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaFirstOrder/ProximalAlgorithms.jl/blob/master/docs/src/guide/getting_started.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h1><p>The methods implemented in ProximalAlgorithms are commonly referred to as (you&#39;ve guessed it) <em>proximal algorithms</em>, in that they rely on the <em>proximal operator</em> (or <em>mapping</em>) to deal with non-differentiable terms in the objective. Loosely speaking, the algorithms in this package can be used to solve problems of the form</p><p class="math-container">\[\operatorname*{minimize}_x\ \sum_{i=1}^N f_i(x)\]</p><p>where <span>$N$</span> depends on the specific algorithm, together with specific assumptions on the terms <span>$f_i$</span> (like smoothness, convexity, strong convexity). The problem above is solved by iteratively accessing specific <em>first order information</em> on the terms <span>$f_i$</span>, like their gradient <span>$\nabla f_i$</span> or their proximal mapping <span>$\operatorname{prox}_{f_i}$</span>:</p><p class="math-container">\[\mathrm{prox}_{\gamma f_i}(x) = \arg\min_z \left\{ f_i(z) + \tfrac{1}{2\gamma}\|z-x\|^2 \right\}\]</p><p>The literature on proximal operators and algorithms is vast: for an overview, one can refer to [<a href="../../bibliography/#Parikh2014">1</a>], [<a href="../../bibliography/#Beck2017">2</a>].</p><p>To evaluate these first-order primitives, in ProximalAlgorithms:</p><ul><li><span>$\nabla f_i$</span> falls back to using automatic differentiation (as provided by <a href="https://github.com/JuliaDiff/AbstractDifferentiation.jl">AbstractDifferentiation</a> and all of its backends).</li><li><span>$\operatorname{prox}_{f_i}$</span> relies on the intereface of <a href="https://github.com/JuliaFirstOrder/ProximalOperators.jl">ProximalOperators</a> (&gt;= 0.15).</li></ul><p>Both of the above can be implemented for custom function types, as <a href="../custom_objectives/#custom_terms">documented here</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Each of the <a href="../implemented_algorithms/#problems_algorithms">implemented algorithms</a> assumes a different structure of the objective to be optimized (e.g., a specific number <span>$N$</span> of terms), with specific assumptions (e.g., smoothness, convexity). Furthermore, multiple algorithms can often be applied to the same problem (possibly through appropriate reformulation) and are expected to perform differently; sometimes, even the <em>same algorithm</em> can be applied in multiple ways to the same problem, by grouping (<em>splitting</em>) the terms in different ways.</p><p>Because of these reasons, ProximalAlgorithms <strong>does not offer a modeling language</strong> to automagically minimize any objective: rather, the user is expected to formulate their problem by providing the right objective terms to the algorithm of choice. Please refer to the <a href="../implemented_algorithms/#problems_algorithms">this section of the manual</a> for information on what terms can be provided and under which assumptions.</p></div></div><h2 id="algorithm_interface"><a class="docs-heading-anchor" href="#algorithm_interface">Interface to algorithms</a><a id="algorithm_interface-1"></a><a class="docs-heading-anchor-permalink" href="#algorithm_interface" title="Permalink"></a></h2><p>At a high level, using algorithms from ProximalAlgorithms amounts to the following.</p><ol><li>Instantiate the algorithm, with options like the termination tolerance, verbosity level, or other algorithm-specific parameters.</li><li>Call the algorithm on the problem description: this amounts to the initial point, the objective terms, and possibly additional required information (e.g. Lipschitz constants).</li></ol><p>See <a href="../implemented_algorithms/#problems_algorithms">here</a> for the list of available algorithm constructors, for different types of problems. In general however, algorithms are instances of the <a href="../custom_algorithms/#ProximalAlgorithms.IterativeAlgorithm"><code>IterativeAlgorithm</code></a> type.</p><h2 id="box_qp"><a class="docs-heading-anchor" href="#box_qp">Example: box constrained quadratic</a><a id="box_qp-1"></a><a class="docs-heading-anchor-permalink" href="#box_qp" title="Permalink"></a></h2><p>As a simple example, consider the minimization of a 2D quadratic function subject to box constraints, which we will solve using the fast proximal gradient method (also known as fast forward-backward splitting):</p><pre><code class="language-julia hljs">using LinearAlgebra
using Zygote
using AbstractDifferentiation: ZygoteBackend
using ProximalOperators
using ProximalAlgorithms

quadratic_cost = ProximalAlgorithms.AutoDifferentiable(
    x -&gt; dot([3.4 1.2; 1.2 4.5] * x, x) / 2 + dot([-2.3, 9.9], x),
    ZygoteBackend(),
)
box_indicator = ProximalOperators.IndBox(0, 1)

ffb = ProximalAlgorithms.FastForwardBackward(maxit = 1000, tol = 1e-5, verbose = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProximalAlgorithms.IterativeAlgorithm{ProximalAlgorithms.FastForwardBackwardIteration, ProximalAlgorithms.var&quot;#34#36&quot;{Float64}, typeof(ProximalAlgorithms.default_solution), typeof(ProximalAlgorithms.default_display), Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}}(1000, ProximalAlgorithms.var&quot;#34#36&quot;{Float64}(1.0e-5), ProximalAlgorithms.default_solution, true, 100, ProximalAlgorithms.default_display, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}())</code></pre><p>Here, we defined the cost function <code>quadratic_cost</code>, and the constraint indicator <code>box_indicator</code>. Then we set up the optimization algorithm of choice, <a href="../implemented_algorithms/#ProximalAlgorithms.FastForwardBackward"><code>FastForwardBackward</code></a>, with options for the maximum number of iterations, termination tolerance, verbosity. Finally, we run the algorithm by providing an initial point and the objective terms defining the problem:</p><pre><code class="language-julia hljs">solution, iterations = ffb(x0 = ones(2), f = quadratic_cost, g = box_indicator)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.6764689822083225, 0.0], 31)</code></pre><p>We can verify the correctness of the solution by checking that the negative gradient is orthogonal to the constraints, pointing outwards: for this, we just evaluate the closure <code>cl</code> returned as second output of <a href="../custom_objectives/#ProximalAlgorithms.value_and_gradient_closure"><code>value_and_gradient_closure</code></a>.</p><pre><code class="language-julia hljs">v, cl = ProximalAlgorithms.value_and_gradient_closure(quadratic_cost, solution)
-cl()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
   5.460491703246362e-6
 -10.711762778649987</code></pre><p>Or by plotting the solution against the cost function and constraint:</p><pre><code class="language-julia hljs">using Plots

contour(
    -1:0.1:2,
    -1:0.1:2,
    (x, y) -&gt; quadratic_cost([x, y]),
    fill = true,
    framestyle = :none,
    background = nothing,
)
plot!(Shape([0, 1, 1, 0], [0, 0, 1, 1]), opacity = 0.5, label = &quot;feasible set&quot;)
scatter!(
    [solution[1]],
    [solution[2]],
    color = :red,
    markershape = :star5,
    label = &quot;computed solution&quot;,
)</code></pre><img src="55cfdf64.svg" alt="Example block output"/><h2 id="iterator_interface"><a class="docs-heading-anchor" href="#iterator_interface">Iterator interface</a><a id="iterator_interface-1"></a><a class="docs-heading-anchor-permalink" href="#iterator_interface" title="Permalink"></a></h2><p>Under the hood, algorithms are implemented in the form of standard Julia iterators: constructing such iterator objects directly, and looping over them, allows for more fine-grained control over the termination condition, or what information from the iterations get logged.</p><p>Each iterator is constructed with the full problem description (objective terms and, if needed, additional information like Lipschitz constats) and algorithm options (usually step sizes, and any other parameter or option of the algorithm), and produces the sequence of states of the algorithm, so that one can do (almost) anything with it.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Iterators only implement the algorithm iteration logic, and not additional details like stopping criteria. As such, iterators usually yield an infinite sequence of states: when looping over them, be careful to properly guard the loop with a stopping criterion.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>To save on allocations, most (if not all) algorithms re-use state objects when iterating, by updating the state <em>in place</em> instead of creating a new one. For this reason:</p><ul><li>one <strong>should not</strong> mutate the state object in any way, as this may corrupt the algorithm&#39;s logic;</li><li>one <strong>should not</strong> <code>collect</code> the sequence of states, since this will result in an array of identical objects.</li></ul></div></div><p>Iterator types are named after the algorithm they implement, so the relationship should be obvious:</p><ul><li>the <code>ForwardBackward</code> algorithm uses the <code>ForwardBackwardIteration</code> iterator type;</li><li>the <code>FastForwardBackward</code> algorithm uses the <code>FastForwardBackwardIteration</code> iterator type;</li><li>the <code>DouglasRachford</code> algorithm uses the <code>DouglasRachfordIteration</code> iterator type;</li></ul><p>and so on.</p><p>Let&#39;s see what this means in terms of the previous example.</p><h2 id="box_qp_cont"><a class="docs-heading-anchor" href="#box_qp_cont">Example: box constrained quadratic (cont)</a><a id="box_qp_cont-1"></a><a class="docs-heading-anchor-permalink" href="#box_qp_cont" title="Permalink"></a></h2><p>Let&#39;s solve the problem from the <a href="#box_qp">previous example</a> by directly interacting with the underlying iterator: the <code>FastForwardBackward</code> algorithm internally uses a <a href="../implemented_algorithms/#ProximalAlgorithms.FastForwardBackwardIteration"><code>FastForwardBackwardIteration</code></a> object.</p><pre><code class="language-julia hljs">ffbiter = ProximalAlgorithms.FastForwardBackwardIteration(
    x0 = ones(2),
    f = quadratic_cost,
    g = box_indicator,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProximalAlgorithms.FastForwardBackwardIteration{Float64, Vector{Float64}, ProximalAlgorithms.AutoDifferentiable{Main.var&quot;#1#2&quot;, AbstractDifferentiation.ReverseRuleConfigBackend{Zygote.ZygoteRuleConfig{Zygote.Context{false}}}}, ProximalOperators.IndBox{Int64, Int64}, Nothing, Nothing, Nothing}(ProximalAlgorithms.AutoDifferentiable{Main.var&quot;#1#2&quot;, AbstractDifferentiation.ReverseRuleConfigBackend{Zygote.ZygoteRuleConfig{Zygote.Context{false}}}}(Main.var&quot;#1#2&quot;(), AbstractDifferentiation.ReverseRuleConfigBackend{Zygote.ZygoteRuleConfig{Zygote.Context{false}}}(Zygote.ZygoteRuleConfig{Zygote.Context{false}}(Zygote.Context{false}(nothing)))), ProximalOperators.IndBox{Int64, Int64}(0, 1), [1.0, 1.0], 0.0, nothing, nothing, true, 1.0e-7, nothing)</code></pre><p>We can now perform anything we want throughout the iteration, by just looping over the iterator: for example, we can store the sequence of iterates from the algorithm, to later plot them, and stop whenever two successive iterates are closer than a given tolerance.</p><pre><code class="language-julia hljs">xs = []
for state in ffbiter
    push!(xs, copy(state.x))
    if length(xs) &gt; 1 &amp;&amp; norm(xs[end] - xs[end-1]) / (1 + norm(xs[end])) &lt;= 1e-5
        break
    end
end

contour(
    -1:0.1:2,
    -1:0.1:2,
    (x, y) -&gt; quadratic_cost([x, y]),
    fill = true,
    framestyle = :none,
    background = nothing,
)
plot!(Shape([0, 1, 1, 0], [0, 0, 1, 1]), opacity = 0.5, label = &quot;feasible set&quot;)
plot!(
    [x[1] for x in xs],
    [x[2] for x in xs],
    markershape = :circle,
    label = &quot;algorithm trajectory&quot;,
)
scatter!(
    [solution[1]],
    [solution[2]],
    color = :red,
    markershape = :star5,
    label = &quot;computed solution&quot;,
)</code></pre><img src="6466eb5c.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Since each algorithm iterator type has its own logic, it will also have its own dedicated state structure. Interacting with the state then requires being familiar with its structure, and with the nature of its attributes.</p></div></div><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../implemented_algorithms/">Problem types and algorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 21 January 2024 16:07">Sunday 21 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
